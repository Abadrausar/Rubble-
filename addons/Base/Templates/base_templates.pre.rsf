
# Templates used in the base

# Note that to keep the output properly formatted templates often have ugly indentation

# The comment templates, very simple, just do nothing.
(rubble:template "COMMENT" {(ret "")})
(rubble:template "C" {(ret "")})

(command rubble:void params {
	(foreach [params] {
		(rubble:stageparse [params 1])
		(break true)
	})
	(ret "")
})
(rubble:template "!VOID" ... {
	(rubble:void [params])
})
(rubble:template "VOID" ... {
	(rubble:void [params])
})
(rubble:template "#VOID" ... {
	(rubble:void [params])
})
(rubble:template "V" ... {
	(rubble:void [params])
})

# ABORT, cause Rubble to exit with an error, not used in the base.
(rubble:template "!ABORT" msg {(rubble:abort [msg])})
(rubble:template "ABORT" msg {(rubble:abort [msg])})
(rubble:template "#ABORT" msg {(rubble:abort [msg])})

# The next templates are for stripping leading/trailing whitespace from a string.
# A formatting tool mostly, helps keep whitespace under control in generated files.
# May also be used to help control variable expansion.
(command rubble:echo params {
	(var tmp)
	(foreach [params] {
		(set tmp (str:add [tmp] [params 1]))
	})
	(rubble:stageparse [tmp])
})
(rubble:template "!ECHO" ... {
	(rubble:echo [params])
})
(rubble:template "ECHO" ... {
	(rubble:echo [params])
})
(rubble:template "#ECHO" ... {
	(rubble:echo [params])
})
(rubble:template "E" ... {
	(rubble:echo [params])
})

# SHARED_OBJECT, the single most important template in all of Rubble
(var rubble:shared_object_data <map>)
(var rubble:shared_object_add_data <map>)
(rubble:template "SHARED_OBJECT" id raws {
	(if (exists [rubble:shared_object_data] [id]){
		(rubble:stageparse [raws])
		(ret "")
	}{
		(set [rubble:shared_object_data] [id] (rubble:stageparse [raws]))
		(ret (str:add "{#_INSERT_SHARED_OBJECT;" [id] "}"))
	})
})
(rubble:template "SHARED_OBJECT_EXISTS" id then "else=" {
	(if (exists [rubble:shared_object_data] [id]) {
		(rubble:stageparse [then])
	}{
		(rubble:stageparse [else])
	})
})
(rubble:template "SHARED_OBJECT_ADD" id raws {
	(set [rubble:shared_object_add_data] [id] (rubble:stageparse [raws]))
	(ret "")
})
(rubble:template "#_INSERT_SHARED_OBJECT" id {
	(if (exists [rubble:shared_object_data] [id]) {
		(var out (rubble:stageparse [rubble:shared_object_data [id]]))
		(if (exists [rubble:shared_object_add_data] [id]) {
			(set out (str:add [out] "\n" (rubble:stageparse [rubble:shared_object_add_data [id]])))
		})
		(ret [out])
	}{
		(ret "")
	})
})

(rubble:template "IF" a b then "else=" {
	(if (str:cmp [a] [b]){
		(rubble:stageparse [then])
	}{
		(rubble:stageparse [else])
	})
})

(rubble:template "SET" name value {
	(rubble:setvar [name] [value])
	(ret "")
})

(var rubble:adventure_tier_data 0)
(rubble:template "#ADVENTURE_TIER" {
	(set rubble:adventure_tier_data (int:add [rubble:adventure_tier_data] 1))
	(ret (str:add "[ADVENTURE_TIER:" [rubble:adventure_tier_data] "]"))
})

(command rubble:print params {
	(foreach [params] {
		(console:print "    " (rubble:expandvars [params 1]) "\n")
		(break true)
	})
	(ret "")
})
(rubble:template "!PRINT" {(rubble:print [params])})
(rubble:template "PRINT" {(rubble:print [params])})
(rubble:template "#PRINT" {(rubble:print [params])})

(rubble:template "SHARED_PLANT" id raws {
	# Tree Tiles
	(regex:replace "\\[TREE_TILE:([0-9]+|'.')\\]" [raws] (str:add "[TREE_TILE:{#TILE;TREE_" [id] ";$1}]"))
	(set raws (nop))
	(regex:replace "\\[DEAD_TREE_TILE:([0-9]+|'.')\\]" [raws] (str:add "[DEAD_TREE_TILE:{#TILE;DEAD_TREE_" [id] ";$1}]"))
	(set raws (nop))
	(regex:replace "\\[SAPLING_TILE:([0-9]+|'.')\\]" [raws] (str:add "[SAPLING_TILE:{#TILE;SAPLING_" [id] ";$1}]"))
	(set raws (nop))
	(regex:replace "\\[DEAD_SAPLING_TILE:([0-9]+|'.')\\]" [raws] (str:add "[DEAD_SAPLING_TILE:{#TILE;DEAD_SAPLING_" [id] ";$1}]"))
	(set raws (nop))
	
	# Tree Colors
	(regex:replace "\\[TREE_COLOR:([0-9]+:[0-9]+:[0-9]+)\\]" [raws] (str:add "[TREE_COLOR:{#COLOR;TREE_" [id] ";$1}]"))
	(set raws (nop))
	(regex:replace "\\[DEAD_TREE_COLOR:([0-9]+:[0-9]+:[0-9]+)\\]" [raws] (str:add "[DEAD_TREE_COLOR:{#COLOR;DEAD_TREE_" [id] ";$1}]"))
	(set raws (nop))
	(regex:replace "\\[SAPLING_COLOR:([0-9]+:[0-9]+:[0-9]+)\\]" [raws] (str:add "[SAPLING_COLOR:{#COLOR;SAPLING_" [id] ";$1}]"))
	(set raws (nop))
	(regex:replace "\\[DEAD_SAPLING_COLOR:([0-9]+:[0-9]+:[0-9]+)\\]" [raws] (str:add "[DEAD_SAPLING_COLOR:{#COLOR;DEAD_SAPLING_" [id] ";$1}]"))
	(set raws (nop))
	
	# Crop Tiles
	(regex:replace "\\[PICKED_TILE:([0-9]+|'.')\\]" [raws] (str:add "[PICKED_TILE:{#TILE;PICKED_" [id] ";$1}]"))
	(set raws (nop))
	(regex:replace "\\[DEAD_PICKED_TILE:([0-9]+|'.')\\]" [raws] (str:add "[DEAD_PICKED_TILE:{#TILE;DEAD_PICKED_" [id] ";$1}]"))
	(set raws (nop))
	(regex:replace "\\[SHRUB_TILE:([0-9]+|'.')\\]" [raws] (str:add "[SHRUB_TILE:{#TILE;SHRUB_" [id] ";$1}]"))
	(set raws (nop))
	(regex:replace "\\[DEAD_SHRUB_TILE:([0-9]+|'.')\\]" [raws] (str:add "[DEAD_SHRUB_TILE:{#TILE;DEAD_SHRUB_" [id] ";$1}]"))
	(set raws (nop))
	
	# Crop Colors
	(regex:replace "\\[PICKED_COLOR:([0-9]+:[0-9]+:[0-9]+)\\]" [raws] (str:add "[PICKED_COLOR:{#COLOR;PICKED_" [id] ";$1}]"))
	(set raws (nop))
	(regex:replace "\\[DEAD_PICKED_COLOR:([0-9]+:[0-9]+:[0-9]+)\\]" [raws] (str:add "[DEAD_PICKED_COLOR:{#COLOR;DEAD_PICKED_" [id] ";$1}]"))
	(set raws (nop))
	(regex:replace "\\[SHRUB_COLOR:([0-9]+:[0-9]+:[0-9]+)\\]" [raws] (str:add "[SHRUB_COLOR:{#COLOR;SHRUB_" [id] ";$1}]"))
	(set raws (nop))
	(regex:replace "\\[DEAD_SHRUB_COLOR:([0-9]+:[0-9]+:[0-9]+)\\]" [raws] (str:add "[DEAD_SHRUB_COLOR:{#COLOR;DEAD_SHRUB_" [id] ";$1}]"))
	(set raws (nop))
	
	# Grass Tiles
	(regex:replace "\\[GRASS_TILES:((?:[0-9]+|'.'):(?:[0-9]+|'.'):(?:[0-9]+|'.'):(?:[0-9]+|'.'))\\]" [raws] (str:add "[GRASS_TILES:{#TILE;GRASS_" [id] ";$1}]"))
	(set raws (nop))
	(regex:replace "\\[ALT_GRASS_TILES:((?:[0-9]+|'.'):(?:[0-9]+|'.'):(?:[0-9]+|'.'):(?:[0-9]+|'.'))\\]" [raws] (str:add "[ALT_GRASS_TILES:{#TILE;ALT_GRASS_" [id] ";$1}]"))
	(set raws (nop))
	
	# Grass Colors
	(regex:replace "\\[GRASS_COLORS:((?:[0-9]+:[0-9]+:[0-9]+):(?:[0-9]+:[0-9]+:[0-9]+):(?:[0-9]+:[0-9]+:[0-9]+):(?:[0-9]+:[0-9]+:[0-9]+))\\]" [raws] (str:add "[GRASS_COLORS:{#COLOR;GRASS_" [id] ";$1}]"))
	(set raws (nop))
	
	(str:add
		"{SHARED_OBJECT;" [id] ";\n"
		"[PLANT:" [id] "]\n\t"
		[raws]
		"\n}"
	)
	(rubble:stageparse (nop))
})

(rubble:template "SHARED_INORGANIC" id raws {
	(regex:replace "\\[ITEM_SYMBOL:([0-9]+|'.')\\]" [raws] (str:add "[ITEM_SYMBOL:{#TILE;ITEM_" [id] ";$1}]"))
	(set raws (nop))
	(regex:replace "\\[TILE:([0-9]+|'.')\\]" [raws] (str:add "[TILE:{#TILE;" [id] ";$1}]"))
	(set raws (nop))
	
	(regex:replace "\\[DISPLAY_COLOR:([0-9]+:[0-9]+:[0-9]+)\\]" [raws] (str:add "[DISPLAY_COLOR:{#COLOR;" [id] ";$1}]"))
	(set raws (nop))
	(regex:replace "\\[BUILD_COLOR:([0-9]+:[0-9]+:[0-9]+)\\]" [raws] (str:add "[BUILD_COLOR:{#COLOR;BUILD_" [id] ";$1}]"))
	(set raws (nop))
	
	(str:add
		"{SHARED_OBJECT;" [id] ";\n"
		"[INORGANIC:" [id] "]\n\t"
		[raws]
		"{#_REGISTERED_REACTION_CLASSES;" [id] "}"
		"{#_REGISTERED_REACTION_PRODUCTS;" [id] "}"
		"\n}"
	)
	(rubble:stageparse (nop))
})

(rubble:template "SHARED_MATERIAL_TEMPLATE" id raws {
	(regex:replace "\\[ITEM_SYMBOL:([0-9]+|'.')\\]" [raws] (str:add "[ITEM_SYMBOL:{#TILE;ITEM_SYMBOL_" [id] ";$1}]"))
	(set raws (nop))
	(regex:replace "\\[TILE:([0-9]+|'.')\\]" [raws] (str:add "[TILE:{#TILE;" [id] ";$1}]"))
	(set raws (nop))
	
	(regex:replace "\\[DISPLAY_COLOR:([0-9]+:[0-9]+:[0-9]+)\\]" [raws] (str:add "[DISPLAY_COLOR:{#COLOR;" [id] ";$1}]"))
	(set raws (nop))
	(regex:replace "\\[BUILD_COLOR:([0-9]+:[0-9]+:[0-9]+)\\]" [raws] (str:add "[BUILD_COLOR:{#COLOR;BUILD_" [id] ";$1}]"))
	(set raws (nop))
	
	(str:add
		"{SHARED_OBJECT;" [id] ";\n"
		"[MATERIAL_TEMPLATE:" [id] "]\n\t"
		[raws]
		"{#_REGISTERED_REACTION_CLASSES;" [id] "}"
		"{#_REGISTERED_REACTION_PRODUCTS;" [id] "}"
		"\n}"
	)
	(rubble:stageparse (nop))
})

(var rubble:reaction_class_data <map>)
(rubble:template "REGISTER_REACTION_CLASS" id class {
	(if (exists [rubble:reaction_class_data] [id]){
	}{
		(set [rubble:reaction_class_data] [id] <map>)
		(set [rubble:reaction_class_data [id]] [class] true)
		(ret "")
	})
	
	(if (exists [rubble:reaction_class_data [id]] [class]){
	}{
		(set [rubble:reaction_class_data [id]] [class] true)
	})
	(ret "")
})
(rubble:template "#_REGISTERED_REACTION_CLASSES" id {
	(if (exists [rubble:reaction_class_data] [id]){
	}{
		(ret "")
	})
	
	(var out "")
	(foreach [rubble:reaction_class_data [id]] {
		(set out (str:add [out] "\n\t[REACTION_CLASS:" [params 0] "]"))
		(break true)
	})
	(ret [out])
})

(var rubble:reaction_product_data <map>)
(rubble:template "REGISTER_REACTION_PRODUCT" id class mat {
	(if (exists [rubble:reaction_product_data] [id]){
	}{
		(set [rubble:reaction_product_data] [id] <map>)
		(set [rubble:reaction_product_data [id]] [class] [mat])
		(ret "")
	})
	
	(if (exists [rubble:reaction_product_data [id]] [class]){
	}{
		(set [rubble:reaction_product_data [id]] [class] [mat])
	})
	(ret "")
})
(rubble:template "#_REGISTERED_REACTION_PRODUCTS" id {
	(if (exists [rubble:reaction_product_data] [id]){
	}{
		(ret "")
	})
	
	(var out "")
	(foreach [rubble:reaction_product_data [id]] {
		(set out (str:add [out] "\n\t[MATERIAL_REACTION_PRODUCT:" [params 0] ":" [params 1] "]"))
		(break true)
	})
	(ret [out])
})

# Tech Templates
(var rubble:building_data <map>)
(rubble:template "BUILDING_WORKSHOP" ... {
	(if (int:lt (len [params]) 2){(panic "Invalid param count to BUILDING_WORKSHOP.")})
	
	(var id [params 0])
	(for {(var count 1)}{(int:lt [count] (len [params]))}{(++ count)}{
		(var class [params [count]])
		
		(if (exists [rubble:building_data] [class]){
			(set [rubble:building_data [class]] (len [rubble:building_data [class]]) [id])
		}{
			(set [rubble:building_data] [class] <array>)
			(set [rubble:building_data [class]] (len [rubble:building_data [class]]) [id])
		})
	})
	(str:add "[BUILDING_WORKSHOP:" [id] "]")
})
(rubble:template "BUILDING_FURNACE" ... {
	(if (int:lt (len [params]) 2){(panic "Invalid param count to BUILDING_FURNACE.")})
	
	(var id [params 0])
	(for {(var count 1)}{(int:lt [count] (len [params]))}{(++ count)}{
		(var class [params [count]])
		
		(if (exists [rubble:building_data] [class]){
			(set [rubble:building_data [class]] (len [rubble:building_data [class]]) [id])
		}{
			(set [rubble:building_data] [class] <array>)
			(set [rubble:building_data [class]] (len [rubble:building_data [class]]) [id])
		})
	})
	(str:add "[BUILDING_FURNACE:" [id] "]")
})
(rubble:template "#USES_BUILDINGS" ... {
	(if (int:lt (len [params]) 1){(panic "Invalid param count to #USES_BUILDINGS.")})
	
	(var buildings <map>)
	(var buildingnames <array>)
	(foreach [params] {
		(var class [params 1])
		(if (exists [rubble:building_data] [class]){
			(foreach [rubble:building_data [class]] {
				(if (exists [buildings] [params 1]){
					'nop'
				}{
					(set [buildings] [params 1] "ok")
					(set [buildingnames] (len [buildingnames]) [params 1])
				})
				(break true)
			})
		})
		(break true)
	})
	
	(var out)
	(foreach [buildingnames] {
		(set out (str:add [out] "\n\t[PERMITTED_BUILDING:" [params 1] "]"))
		(break true)
	})
	(ret (str:trimspace [out]))
})

(var rubble:reaction_data <map>)
(rubble:template "REACTION" ... {
	(if (int:lt (len [params]) 2){(panic "Invalid param count to REACTION.")})
	
	(var id [params 0])
	(for {(var count 1)}{(int:lt [count] (len [params]))}{(++ count)}{
		(var class [params [count]])
		
		(if (exists [rubble:reaction_data] [class]){
			(set [rubble:reaction_data [class]] (len [rubble:reaction_data [class]]) [id])
		}{
			(set [rubble:reaction_data] [class] <array>)
			(set [rubble:reaction_data [class]] (len [rubble:reaction_data [class]]) [id])
		})
	})
	(str:add "[REACTION:" [id] "]")
})
(rubble:template "#USES_REACTIONS" ... {
	(if (int:lt (len [params]) 1){(panic "Invalid param count to #USES_REACTIONS.")})
	
	(var reactions <map>)
	(var reactionnames <array>)
	(foreach [params] {
		(var class [params 1])
		(if (exists [rubble:reaction_data] [class]){
			(foreach [rubble:reaction_data [class]] {
				(if (exists [reactions] [params 1]){
					# nop
				}{
					(set [reactions] [params 1] "ok")
					(set [reactionnames] (len [reactionnames]) [params 1])
				})
				(break true)
			})
		})
		(break true)
	})
	
	(var out)
	(foreach [reactionnames] {
		(set out (str:add [out] "\n\t[PERMITTED_REACTION:" [params 1] "]"))
		(break true)
	})
	(ret (str:trimspace [out]))
})

(rubble:template "#USES_TECH" ... {
	(if (int:lt (len [params]) 1){(panic "Invalid param count to #USES_TECH.")})
	
	(var buildings <map>)
	(var buildingnames <array>)
	(var reactions <map>)
	(var reactionnames <array>)
	(foreach [params] {
		(var class [params 1])
		(if (exists [rubble:building_data] [class]){
			(foreach [rubble:building_data [class]] {
				(if (exists [buildings] [params 1]){
					# nop
				}{
					(set [buildings] [params 1] true)
					(set [buildingnames] (len [buildingnames]) [params 1])
				})
				(break true)
			})
		})
		(if (exists [rubble:reaction_data] [class]){
			(foreach [rubble:reaction_data [class]] {
				(if (exists [reactions] [params 1]){
					# nop
				}{
					(set [reactions] [params 1] true)
					(set [reactionnames] (len [reactionnames]) [params 1])
				})
				(break true)
			})
		})
		(break true)
	})
	
	(var out)
	(foreach [buildingnames] {
		(set out (str:add [out] "\n\t[PERMITTED_BUILDING:" [params 1] "]"))
		(break true)
	})
	(foreach [reactionnames] {
		(set out (str:add [out] "\n\t[PERMITTED_REACTION:" [params 1] "]"))
		(break true)
	})
	(ret (str:trimspace [out]))
})

# Item templates
(var rubble:item_current_id "")
(var rubble:item_current_type "")

# Set to true if item type allows rarity
(var rubble:item_types <map
	AMMO=false
	ARMOR=true
	DIGGER=false
	GLOVES=true
	HELM=true
	INSTRUMENT=false
	PANTS=true
	SHIELD=false
	SHOES=true
	SIEGEAMMO=false
	TOOL=false
	TOY=false
	TRAPCOMP=false
	WEAPON=false
>)

(var rubble:item_rarities <map
	RARE=1
	UNCOMMON=2
	COMMON=3
	FORCED=4
>)

(var rubble:item_data <map>)
(rubble:template "SHARED_ITEM" type id def {
	(if (str:cmp [type] "FOOD") {
		# FOOD doesn't need to be registered in an entity, so translate it directly to a SHARED_OBJECT call.
		(ret (rubble:stageparse (str:add "{SHARED_OBJECT;" [id] ";\n[ITEM_" [type] ":" [id] "]\n\t" [def] "\n}")))
	})
	
	(set rubble:item_current_id [id])
	(set rubble:item_current_type [type])
	
	(if (exists [rubble:item_types] [type]){
	}{
		(panic "Invalid item type passed to SHARED_ITEM.")
	})
	
	(regex:replace "\\[TILE:([0-9]+|'.')\\]" [def] (str:add "[TILE:{#TILE;" [id] ";$1}]"))
	(set def (nop))
	
	(if (str:cmp [type] "DIGGER") {
		(set type "WEAPON")
	})
	
	(rubble:stageparse (str:add "{SHARED_OBJECT;" [id] ";\n[ITEM_" [type] ":" [id] "]\n\t" [def] "\n}"))
})
(rubble:template "ITEM_CLASS" ... {
	(var type [rubble:item_current_type])
	(var id [rubble:item_current_id])
	(var class "")
	(var rarity "COMMON")
	
	(if (int:eq (len [params]) 1){
		# class only
		(set class [params 0])
	}{
		(if (int:eq (len [params]) 2){
			# class + rarity
			(set class [params 0])
			(set rarity [params 1])
		}{
			(if (int:eq (len [params]) 3){
				# all but rarity
				(set type [params 0])
				(set id [params 1])
				(set class [params 2])
			}{
				(if (int:eq (len [params]) 4){
					# full call
					(set type [params 0])
					(set id [params 1])
					(set class [params 2])
					(set rarity [params 3])
				}{
					(panic "Invalid param count to ITEM_CLASS.")
				})
			})
			
		})
	})
	
	(if (exists [rubble:item_rarities] [rarity]){
	}{
		(panic "Invalid item rarity passed to ITEM_CLASS.")
	})
	
	(if (exists [rubble:item_data] [class]){
		(if (exists [rubble:item_data [class]] [rubble:item_current_id]) {
		}{
			(set [rubble:item_data [class]] [rubble:item_current_id] <map
				rarity=[rarity]
				type=[rubble:item_current_type]
			>)
		})
	}{
		(set [rubble:item_data] [class] <map
			[rubble:item_current_id]=<map
				rarity=[rarity]
				type=[rubble:item_current_type]
			>
		>) 
	})
	(ret "")
})
(rubble:template "#USES_ITEMS" class {
	(var out)
	(if (exists [rubble:item_data] [class]){
		(foreach [rubble:item_data [class]] {
			(var type [rubble:item_data [class] [params 0] type])
			(var rarity [rubble:item_data [class] [params 0] rarity])
			(if [rubble:item_types [type]] {
				# Has rarity
				(set out (str:add [out] "\n\t[" [type] ":" [params 0] ":" [rarity] "]"))
			}{
				# Does not have rarity
				(set out (str:add [out] "\n\t[" [type] ":" [params 0] "]"))
			})
			(break true)
		})
	})
	(str:trimspace [out])
})

# combination of #USES_TECH and #USES_ITEMS, for internal use.
(rubble:template "#_ADDON_HOOK" class {
	(var out (str:add "# Hook: " [class]))
	
	# Items
	(if (exists [rubble:item_data] [class]){
		(foreach [rubble:item_data [class]] {
			(var type [rubble:item_data [class] [params 0] type])
			(var rarity [rubble:item_data [class] [params 0] rarity])
			(if [rubble:item_types [type]] {
				# Has rarity
				(set out (str:add [out] "\n\t[" [type] ":" [params 0] ":" [rarity] "]"))
			}{
				# Does not have rarity
				(set out (str:add [out] "\n\t[" [type] ":" [params 0] "]"))
			})
			(break true)
		})
	})
	
	(var buildings <map>)
	(var buildingnames <array>)
	(var reactions <map>)
	(var reactionnames <array>)
	
	(if (exists [rubble:building_data] [class]){
		(foreach [rubble:building_data [class]] {
			(if (exists [buildings] [params 1]){
				# nop
			}{
				(set [buildings] [params 1] true)
				(set [buildingnames] (len [buildingnames]) [params 1])
			})
			(break true)
		})
	})
	(if (exists [rubble:reaction_data] [class]){
		(foreach [rubble:reaction_data [class]] {
			(if (exists [reactions] [params 1]){
				# nop
			}{
				(set [reactions] [params 1] true)
				(set [reactionnames] (len [reactionnames]) [params 1])
			})
			(break true)
		})
	})
	
	(foreach [buildingnames] {
		(set out (str:add [out] "\n\t[PERMITTED_BUILDING:" [params 1] "]"))
		(break true)
	})
	(foreach [reactionnames] {
		(set out (str:add [out] "\n\t[PERMITTED_REACTION:" [params 1] "]"))
		(break true)
	})
	
	(str:trimspace [out])
})

(rubble:template "ADDON_HOOKS" id "playable=false" {

	(var out (str:add
		"{#_ADDON_HOOK;ADDON_HOOK_" [id] "}\n"
		"\t{#_ADDON_HOOK;ADDON_HOOK_GENERIC}"
		(if [playable] {"\n\t{#_ADDON_HOOK;ADDON_HOOK_PLAYABLE}"}{""})
	))
})
