
(namespace rubble:libs_crates)
(var rubble:libs_crates:data <map>)
(var rubble:libs_crates:classes <map>)
(var rubble:libs_crates:last "")

# Define a new crate.
(rubble:template "!CRATE" id name value product {
	(if (exists [rubble:libs_crates:data] [id]){
		(rubble:abort "Error: Crate already exists.")
	}{
		(set rubble:libs_crates:last [id])
		(set [rubble:libs_crates:data] [id] <map
			name=[name]
			value=[value]
			product=[product]
			bar=false
		>)
	})
	(ret "")
})

# Define a new crate (containing 10 bars).
(rubble:template "!CRATE_BARS" id name value product {
	(if (exists [rubble:libs_crates:data] [id]){
		(rubble:abort "Error: Crate already exists.")
	}{
		(set rubble:libs_crates:last [id])
		(set [rubble:libs_crates:data] [id] <map
			name=(str:add [name] " bars (10)")
			value=[value]
			product=[product]
			bar=true
		>)
	})
	(ret "")
})

# Add last defined crate to class.
# Crates may have more than one class.
# !CRATE_CLASS class | !CRATE_CLASS id class
(rubble:template "!CRATE_CLASS" ... {
	(var id [rubble:libs_crates:last])
	(var class "")
	
	(if (int:eq (len [params]) 1){
		# class only
		(set class [params 0])
	}{
		(if (int:eq (len [params]) 2){
			# id + class
			(set id [params 0])
			(set class [params 1])
		}{
			(rubble:abort "Error: Invalid param count to !CRATE_CLASS.")
		})
	})
	
	(if (exists [rubble:libs_crates:classes] [class]){
		(set [rubble:libs_crates:classes [class]] (len [rubble:libs_crates:classes [class]]) [id])
	}{
		(set [rubble:libs_crates:classes] [class] <array [id]>)
	})
	
	(ret "")
})

# This generates a list of product lines for all crates, use in world gen reactions.
(rubble:template "CRATE_WORLDGEN_REACTION_PRODUCTS" class {
	(var out "")
	(foreach [rubble:libs_crates:data] {
		(set out (str:add
			[out]
			"\t[PRODUCT:100:1:BAR:NONE:CREATURE_MAT:LIBS_CRATES_CREATURE:" [params 0] "][PRODUCT_DIMENSION:150]\n"
		))
		(break true)
	})
	(str:trimspace [out])
})

# This generates a list of product lines for a crate class, use in world gen reactions.
(rubble:template "CRATE_WORLDGEN_REACTION_PRODUCTS_CLASSED" class {
	(if (exists [rubble:libs_crates:classes] [class]){
		(var out "")
		(foreach [rubble:libs_crates:classes [class]] {
			(str:add
				[out] "\n\t"
				"[PRODUCT:100:1:BAR:NONE:CREATURE_MAT:LIBS_CRATES_CREATURE:" [params 1] "][PRODUCT_DIMENSION:150]"
			)
			(set out (nop))
			(break true)
		})
		(str:trimspace [out])
	}{
		(ret "")
	})
})

# Generate unpack reactions for all rubble:libs_crates.
# Example:
# {CRATE_UNPACK_REACTIONS;CRAFTSMAN;CARPENTRY;ADDON_HOOK_PLAYABLE}
(rubble:template "CRATE_UNPACK_REACTIONS" building skill techclass auto=true {
	(var out "")
	(foreach [rubble:libs_crates:data] {
		(if [[params 1] bar] {
			(set out (str:add
				[out] "\n"
				"{REACTION;UNPACK_" [params 0] ";" [techclass] "}\n"
				"\t[NAME:unpack " [[params 1] name] "]\n"
				"\t[BUILDING:" [building] ":NONE]\n"
				"\t[REAGENT:A:150:BAR:NONE:NONE:NONE:" [params 0] "]\n"
				"\t\t[HAS_MATERIAL_REACTION_PRODUCT:CRATE_" [params 0] "_MAT]"
				"\t[SKILL:" [skill] "]\n"
				"\t[PRODUCT:100:10:BAR:NONE:GET_MATERIAL_FROM_REAGENT:A:CRATE_" [params 0] "_MAT]\n"
				(if [auto] {"\t[AUTOMATIC]\n"}{""})
			))
			(breakloop true)
		})
		
		(set out (str:add
			[out] "\n"
			"{REACTION;UNPACK_" [params 0] ";" [techclass] "}\n"
			"\t[NAME:unpack " [[params 1] name] "]\n"
			"\t[BUILDING:" [building] ":NONE]\n"
			"\t[REAGENT:A:150:BAR:NONE:CREATURE_MAT:LIBS_CRATES_CREATURE:" [params 0] "]\n"
			"\t[SKILL:" [skill] "]\n"
			"\t" [[params 1] product] "\n"
			(if [auto] {"\t[AUTOMATIC]\n"}{""})
		))
		(break true)
	})
	(str:trimspace (rubble:stageparse [out]))
})

# Same as CRATE_UNPACK_REACTIONS, except for only a single crate class.
(rubble:template "CRATE_UNPACK_REACTIONS_CLASSED" building skill techclass crateclass auto=true {
	(if (exists [rubble:libs_crates:classes] [crateclass]){
		(var out "")
		(foreach [rubble:libs_crates:classes [crateclass]] {
			(var id [params 1])
			
			(if [rubble:libs_crates:data [id] bar] {
				(set out (str:add
					[out] "\n"
					"{REACTION;UNPACK_" [id] ";" [techclass] "}\n"
					"\t[NAME:unpack " [rubble:libs_crates:data [id] name] "]\n"
					"\t[BUILDING:" [building] ":NONE]\n"
					"\t[REAGENT:A:150:BAR:NONE:NONE:NONE:" [id] "]\n"
					"\t\t[HAS_MATERIAL_REACTION_PRODUCT:CRATE_" [id] "_MAT]"
					"\t[SKILL:" [skill] "]\n"
					"\t[PRODUCT:100:10:BAR:NONE:GET_MATERIAL_FROM_REAGENT:A:CRATE_" [id] "_MAT]\n"
					(if [auto] {"\t[AUTOMATIC]\n"}{""})
				))
				(breakloop true)
			})
			
			(set out (str:add
				[out] "\n"
				"{REACTION;UNPACK_" [id] ";" [techclass] "}\n"
				"\t[NAME:unpack " [rubble:libs_crates:data [id] name] "]\n"
				"\t[BUILDING:" [building] ":NONE]\n"
				"\t[REAGENT:A:150:BAR:NONE:CREATURE_MAT:LIBS_CRATES_CREATURE:" [id] "]\n"
				"\t[SKILL:" [skill] "]\n"
				"\t" [[rubble:libs_crates:data [id]] product] "\n"
				(if [auto] {"\t[AUTOMATIC]\n"}{""})
			))
			(break true)
		})
		(str:trimspace (rubble:stageparse [out]))
	}{
		(ret "")
	})
})
