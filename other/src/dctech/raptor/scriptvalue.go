/*
Copyright 2012-2013 by Milo Christiansen

This software is provided 'as-is', without any express or implied warranty. In
no event will the authors be held liable for any damages arising from the use of
this software.

Permission is granted to anyone to use this software for any purpose, including
commercial applications, and to alter it and redistribute it freely, subject to
the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim
that you wrote the original software. If you use this software in a product, an
acknowledgment in the product documentation would be appreciated but is not
required.

2. Altered source versions must be plainly marked as such, and must not be
misrepresented as being the original software.

3. This notice may not be removed or altered from any source distribution.
*/

package raptor

//import "fmt"
import "strconv"

const (
	TypObject  = iota // Generic data, possibly an Indexable.
	TypString         // A string
	TypInt            // An int64
	TypFloat          // A float64
	TypBool           // A boolean
	TypCode           // A *CompiledScript
	TypCommand        // A command reference, basicly a string with a special type value.
)

// Why do I have this type? It makes refactoring easier.
type EmptyInterface interface{}

// Value is a simple script value.
type Value struct {
	Type int
	Data EmptyInterface
	Pos  *PositionInfo
}

// NewValueString creates a new Value from a string
func NewValueString(val string) *Value {
	this := new(Value)
	this.Type = TypString
	this.Data = val
	this.Pos = NewPositionInfo(0, -1)
	return this
}

// NewValueInt64 creates a new Value from a int64
func NewValueInt64(val int64) *Value {
	this := new(Value)
	this.Type = TypInt
	this.Data = val
	this.Pos = NewPositionInfo(0, -1)
	return this
}

// NewValueFloat64 creates a new Value from a float64
func NewValueFloat64(val float64) *Value {
	this := new(Value)
	this.Type = TypFloat
	this.Data = val
	this.Pos = NewPositionInfo(0, -1)
	return this
}

// NewValueBool creates a new Value from a bool
func NewValueBool(val bool) *Value {
	this := new(Value)
	this.Type = TypBool
	this.Data = val
	this.Pos = NewPositionInfo(0, -1)
	return this
}

// NewValueCode creates a new Value from a *CompiledScript
func NewValueCode(val *CompiledScript) *Value {
	this := new(Value)
	this.Type = TypCode
	this.Data = val
	this.Pos = NewPositionInfo(0, -1)
	return this
}

// NewValueObject creates a new Value with the type TypObject
func NewValueObject(val EmptyInterface) *Value {
	this := new(Value)
	this.Type = TypObject
	this.Data = val
	this.Pos = NewPositionInfo(0, -1)
	return this
}

// NewValueCommand creates a new Value with the type TypCommand
func NewValueCommand(val string) *Value {
	this := new(Value)
	this.Type = TypCommand
	this.Data = val
	this.Pos = NewPositionInfo(0, -1)
	return this
}

// TokenToValue turns a lexer token into a script value using the following rules.
// 	if lexeme is "true" or "false" type is bool
//	if lexeme can be converted into an int without error type is int
//	if lexeme can be converted into a float without error type is float
//	else type is string
func TokenToValue(tok *Token) *Value {
	this := new(Value)
	this.Pos = tok.Pos

	if tok.Lexeme == "true" {
		this.Type = TypBool
		this.Data = true
		return this
	}

	if tok.Lexeme == "false" {
		this.Type = TypBool
		this.Data = false
		return this
	}

	intval, err := strconv.ParseInt(tok.Lexeme, 0, 64)
	if err == nil {
		this.Type = TypInt
		this.Data = intval
		return this
	}

	//fltval, err := strconv.ParseFloat(tok.Lexeme, 64)
	//if err == nil {
	//	this.Type = TypFloat
	//	this.Data = fltval
	//	return this
	//}

	this.Type = TypString
	this.Data = tok.Lexeme
	return this
}

// CodeString converts a Value to a parseable string.
// The result of parsing a string returned by CodeString may not be the same as the value it was generated from.
// This function is not very useful as it is imposible to save just anything, only some values can be retrived.
// Also the code generated by this function may need the command "getcommand" to be defined.
// The output of this function is not to be displayed to the user, this is strictly for implimenting
// possible future support for making object literals from existing Indexables for saving state and the like.
func (this *Value) CodeString() string {
	switch this.Type {
	case TypString:
		return "\"" + EscapeString(this.Data.(string)) + "\""

	case TypInt:
		return strconv.FormatInt(this.Data.(int64), 10)

	case TypFloat:
		return strconv.FormatFloat(this.Data.(float64), 'g', -1, 64)

	case TypBool:
		if this.Data.(bool) {
			return "true"
		}
		return "false"

	case TypCode:
		return this.CompiledScript().String()

	case TypCommand:
		return "(getcommand \"" + this.Data.(string) + "\")"

	case TypObject:
		index := this.Indexable()
		if index == nil {
			return "\"<UserData>\""
		}

		return index.CodeString()
	}
	panic("CodeString: Script Value has invalid Type.")
}

// String converts a Value to a string.
// The value generated by this function is not always useful for anything but display to a user.
func (this *Value) String() string {
	switch this.Type {
	case TypString:
		return this.Data.(string)

	case TypInt:
		return strconv.FormatInt(this.Data.(int64), 10)

	case TypFloat:
		return strconv.FormatFloat(this.Data.(float64), 'g', -1, 64)

	case TypBool:
		if this.Data.(bool) {
			return "true"
		}
		return "false"

	case TypCode:
		return this.CompiledScript().String()

	case TypCommand:
		return this.Data.(string)

	case TypObject:
		index := this.Indexable()
		if index == nil {
			return "<UserData>"
		}

		return index.String()
	}
	panic("String: Script Value has invalid Type.")
}

// Int64 converts a Value to an int64.
// Objects and invalid strings are always 0.
func (this *Value) Int64() int64 {
	switch this.Type {
	case TypString:
		val, err := strconv.ParseInt(this.Data.(string), 0, 64)
		if err != nil {
			val = 0
		}
		return val

	case TypInt:
		return this.Data.(int64)

	case TypFloat:
		return int64(this.Data.(float64))

	case TypBool:
		if this.Data.(bool) {
			return -1
		}
		return 0

	case TypCode:
		return 0

	case TypCommand:
		return 0

	case TypObject:
		return 0
	}
	panic("Int64: Script Value has invalid Type.")
}

// Int64 converts a Value to an int64.
// Objects and invalid strings are always 0.0.
func (this *Value) Float64() float64 {
	switch this.Type {
	case TypString:
		val, err := strconv.ParseFloat(this.Data.(string), 64)
		if err != nil {
			val = 0.0
		}
		return val

	case TypInt:
		return float64(this.Data.(int64))

	case TypFloat:
		return this.Data.(float64)

	case TypBool:
		if this.Data.(bool) {
			return 1.0
		}
		return 0.0

	case TypCode:
		return 0.0

	case TypCommand:
		return 0.0

	case TypObject:
		return 0.0
	}
	panic("Float64: Script Value has invalid Type.")
}

// Bool converts a Value to a bool.
// Strings return false for "0", "false", or "".
// Ints are true if the value is anything other than 0.
// Floats are converted to ints and then converted to bool by the int rules.
// Code and commands are always true
// Objects are false if the value's data is nil.
func (this *Value) Bool() bool {
	switch this.Type {
	case TypString:
		return (this.Data.(string) != "" && this.Data.(string) != "0" && this.Data.(string) != "false")

	case TypInt:
		return this.Data.(int64) != 0

	case TypFloat:
		return int64(this.Data.(float64)) != 0

	case TypBool:
		return this.Data.(bool)

	case TypCode:
		return true

	case TypCommand:
		return true

	case TypObject:
		return this.Data != nil
	}
	panic("Bool: Script Value has invalid Type.")
}

// CompiledScript converts a Value to a *CompiledScript.
func (this *Value) CompiledScript() *CompiledScript {
	switch this.Type {
	case TypString:
		return Compile(this.Data.(string), this.Pos)
	case TypCode:
		return this.Data.(*CompiledScript)
	default:
		return Compile(this.String(), this.Pos)
	}
	panic("UNREACHABLE")
}

// CodeSource converts a Value to a CodeSource.
func (this *Value) CodeSource() CodeSource {
	switch this.Type {
	case TypString:
		return NewLexer(this.Data.(string), this.Pos.Line, this.Pos.Column)
	case TypCode:
		return NewCompiledLexer(this.Data.(*CompiledScript))
	default:
		return NewLexer(this.String(), this.Pos.Line, this.Pos.Column)
	}
	panic("UNREACHABLE")
}

// Indexable will try to return the value's data as an Indexable, returns nil on failure.
func (this *Value) Indexable() Indexable {
	if this.Type != TypObject {
		return nil
	}
	return ToIndexable(this.Data)
}

// EditIndexable will try to return the value's data as an EditIndexable, returns nil on failure.
func (this *Value) EditIndexable() EditIndexable {
	if this.Type != TypObject {
		return nil
	}
	return ToEditIndexable(this.Data)
}

// Formatting Functions

// EscapeString will escape (some) special chars in a string to (try to) make it into a valid Raptor DQString.
func EscapeString(input string) string {
	in := []byte(input)
	out := make([]byte, 0, len(in))
	for i := range in {
		switch in[i] {
		case '\n':
			out = append(out, "\\n"...)
		case '\r':
			out = append(out, "\\r"...)
		case '"':
			out = append(out, "\\\""...)
		case '\\':
			out = append(out, "\\\\"...)
		default:
			out = append(out, in[i])
		}
	}
	return string(out)
}
