
Raptor Basics

==============================================
Overview:
==============================================

Raptor is a custom scripting language I wrote that is designed to be easy to embed and extend. Raptor is based on an earlier language of mine named NCA, which in turn is heavily influenced by TCL. Like TCL the base syntax is very simple.

Raptor is not an acronym, it's just a name.

This file makes no mention of specific commands, and so it is a little bare-bones. It would be a very good idea to read the command and package documentation in addition to this document.

==============================================
Comments
==============================================

Raptor only supports one kind of comment: a simple line comment marked by a # symbol.
Example: # comment

==============================================
String Syntax
==============================================

Raptor supports two kinds of strings: the raw string and the double quote string.

The raw string is simply a group of characters with no white space or commas like so: example_raw_string

A double quote string is like the strings supported by most languages, complete with support for the common escape sequences. Double quote strings may also contain newlines and other special characters.
Supported escape sequences: \n \r \t \" \\ \xFF (where FF is any hex number)

==============================================
Commands
==============================================

A command is Raptor's version of a function, except in Raptor commands also do stuff that is handled by keywords in most languages. To call a command you surround a string containing its name in parentheses, along with any parameter you wish to pass in. 
Example: (The comas are optional)
	(test_command, test_param_1, "test param 2")

Commands may be named any valid string but by convention they are all raw strings

There is no syntax for declaring new user commands, that must be done by a command.

==============================================
Variables
==============================================

Variable support in Raptor is like command support, you can read them but not declare them. Declaring a variable is done via a command.

To read a variable you surround its name in square brackets like so: [example_variable]
Variables may contain objects, objects may be Indexable, if so you may pass in a second parameter, the index you want to retrieve: [example_variable, 1]
To read from nested indexables you may either nest the dereferences or just pass them in as a list like so: [test_var 1 2 3] (needless to say the second way is better)
Dereference Syntax: [variable [index...]]

==============================================
Namespaces and Environments
==============================================

Variables are stored in environments or namespaces (namespaces may also hold commands and other namespaces). 

Environments are created and destroyed automatically by the State when a user command is called and possibly by some other commands, users have little (direct) control over them. When an environment is destroyed all variables in it are destroyed as well. If the user asks for a variable the current environment is checked first, if the variable is not found then the next one up is checked and so on.

Namespaces must be created by the user via a command, but after a namespace is created it may be written and read from freely. To retrieve a value (or call a command) in a namespace, prefix its name with the namespace name separated by a colon eg. namespace_name:other_name The same procedure is used to add a value, just prefix the name you pass to a declaration command.

==============================================
Values
==============================================

Script values are stored internally as several types: string, int, float, bool, code, command, and object.

The run-time knows how to convert between types automatically, though some types will not yield useful data if converted.

The parser examines incoming data and tries to convert it to the various types using these rules:
	if lexeme is "true" or "false" type is bool
	if lexeme can be converted into an int without error type is int
	if lexeme can be converted into a float without error type is float
	else type is string

For Objects there is a special syntax. The Object literal syntax only works for types that are registered with the state.
Object Syntax: <type [key=value...]> or <type [value...]>

Objects are special in that they may be literally anything that a command wants to stuff into a value. Most of the time an object is only understood by commands from the same package as the command that generated it, the exception to this is if the object is Indexable. An Indexable object is special in that the run-time understands how to read data from it natively using the indexing dereference operator. Indexables also have a special interface they present to native commands that allows them to: read data, write data (only some), get a list of keys, and get the key count. Indexables are usually things like arrays and maps but may be anything that can implement the correct interface.

Code values are also special, they may be used instead of strings in some commands. 
Code values have their own special syntax: {<any amount of valid Raptor code>}
Code values act like strings as far as the user is concerned except one important rule: Code blocks can not contain anything other than valid Raptor code.

Command values are references to specific commands, generally used for things like call-backs and OOP emulation.
To use a command value just use it in the place of a command name.
([commandvalue] param1 param2...)
Command values are simply strings that contain the command name, the special type is needed to allow for easy support for the This register, which is very important to OOP emulation.

==============================================
Conclusion
==============================================

The above simple rules are all there is to the Raptor base language, everything else is done via commands. Raptor is really pretty useless unless at least the base commands are loaded.
