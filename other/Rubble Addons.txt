
==============================================
How to Write a Rubble Addon
==============================================

There used to be a tutorial here, but it got badly obsolete.
For now I have just removed it.

==============================================
Tileset Addons:
==============================================

Tileset addons may be created via these steps:
Setup a copy of Rubble with an empty base and no addons 
Run three regex search and replace operations on the tileset's raws:
	\[INORGANIC:([^:\]]+)\] -> }{SHARED_INORGANIC;$1;
	\[PLANT:([^:\]]+)\] -> }{SHARED_PLANT;$1;
	\[MATERIAL_TEMPLATE:([^:\]]+)\] -> }{SHARED_MATERIAL_TEMPLATE;$1;
Now remove the extra "}" at the beginning of each modified file and add a "}" to the end
Copy the modified files into a new addon
Add copies of any raw files that contain tool items to your addon
Wrap all tile numbers in tool items with calls to #TILE
Add a file named "zzz_write_tiles.rbl" to your addon
Add this template call to "zzz_write_tiles.rbl": {#WRITE_TILESET;./tileset.rbl}

The above steps should create a file named "tileset.rbl", this file has all the needed calls to SET_TILE and SET_COLOR. Now all you need to do is use a script to install the tileset's image files and edit the init files, see the mlc_tileset addon for such a script.

==============================================
Tweak Scripts:
==============================================

Tweak scripts are the most important thing to happen to Rubble since version 1. They allow you to run arbitrary scripts before or after generation. These scripts can change the raws, allowing you to "tweak" the generated output.

Tweak scripts are written in Raptor not Rubble code, so Rubble templates are not available except through rubble:calltemplate.
Each tweak script runs in its own environment just like a Raptor user command. The params array is NOT set!

Most tweak scripts will make use of the commands in the raw namespace to walk the raw files and make changes as needed.

As for writing your own tweak scripts... I suggest you not try unless you have a good understanding of the Raptor language. It would be a very good idea to read the tweak scripts included with Rubble, if you do not understand those (rather simple) scripts then you will have trouble writing your own.

Pitfalls to keep in mind:
	break, if and loop interaction
		break is not at all like the break keyword in most programming languages, for example this example will not work as expected:
			(loop {
				(if (int:eq 1 1) {
					(console:print "1==1")
					(break false)
				})
				(console:print "1!=1 O_O")
				(break true)
			})
		The first break will just make the if command return false. To get the loop to exit you will need to make sure the if command is the last command in the loop. This example is easy to fix, just move the last two commands to the if commands false block, but in many cases it is not so easy.
		The reason that break works the way it does is that break is simply a "soft" return, eg it returns at most one block.
		 
		The breakloop command is much more like the common break keyword but it only works with commands that handle the BreakLoop exit state (loop and foreach as of Raptor v1.0)
		
		The above example rewritten with breakloop:
			(loop {
				(if (int:eq 1 1) {
					(console:print "1==1")
					(breakloop false)
				})
				(console:print "1!=1 O_O")
				
				# equivalent to most languages continue keyword
				# in this case a normal break or even just a bare true would work as well
				(breakloop true)
			})
	
	Declaring variables in loop and foreach
		To put it simply, you can't. Or rather you can, but Rubble will crash with an error on the next iteration. Remember to declare your variables ahead of time and if you REALLY don't want them around after the loop exits just delvar them away or surround the whole mess in a call to evalinnew.

==============================================
Archived Addons:
==============================================

There are two ways to pack addons into zip files:
	One addon per zip, with all addon files in the root of the archive
	Multiple addons per zip, with each addon in a directory in the root of the archive

To make Rubble recognize an archive as a pack file (multiple addons per archive) you need to use the extension .pack.zip

Examples:

test_addon.zip
	file1.txt
	file2.rbl
	file3.pre.rsf
	
Test Pack.pack.zip
	addon1
		do_something.post.rsf
	addon2
		some_file.txt

==============================================
Other Random Information:
==============================================

If you want to allow an item, reaction, or building with a minimum of fuss register it as class "ADDON_HOOK_MOUNTAIN" or "ADDON_HOOK_PLAYABLE". Addon hooks also exist for the other entities.

If you are making a template that takes a variable number of params and you want to implement it via a different template you may need the ... param.
Example:
	{!TEMPLATE;E;
		{ECHO;...}
	}
If Rubble finds a template call where the last param is ... it appends the params from the previous template call to the current template's params. This trick is good for aliases.

There is no check for infinite recursion, so make sure you never recurse without breaking out at some point (unless you want to cause an infinite loop and eat all your memory until Rubble crashes)
