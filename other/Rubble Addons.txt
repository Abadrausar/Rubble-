
==============================================
How to Write a Rubble Addon
==============================================

There are some tutorials in the file "How To Rubble.txt", I suggest you read them as they explain the basics in some detail.

==============================================
Template Prefixes Explained:
==============================================

When a template is run is determined by a one character prefix (or lack of a prefix).
There are three parse stages and four prefixes.
Prefix	Meaning
!		Preparse, a template with this prefix will run in the preparse stage.
none	Parse, a template with no prefix will run in the parse stage.
#		Postparse, a template with this prefix will run in the postparse stage.
@		ASAP, a template with this prefix will run in the earliest possible parse stage.

@ templates are usually run in preparse but could be run in any stage depending on when it is parsed (parsing can be delayed by nesting in a later parse stage template for example).

The template prefix is part of the template's name, you cannot change a template's parse stage by calling it with a different prefix (unless you rename the template)

==============================================
Tileset Addons:
==============================================

Tileset addons may be automatically generated from existing raws via these steps:
Setup a copy of Rubble with an empty base and no addons 
Run four regex search and replace operations on the tileset's raws:
	\[INORGANIC:([^:\]]+)\] -> }{SHARED_INORGANIC;$1;
	\[PLANT:([^:\]]+)\] -> }{SHARED_PLANT;$1;
	\[MATERIAL_TEMPLATE:([^:\]]+)\] -> }{SHARED_MATERIAL_TEMPLATE;$1;
	\[ITEM_([^:\]]+):([^:\]]+)\] -> }{SHARED_ITEM;$1;$2;
Now remove the extra "}" at the beginning of each modified file and add a "}" to the end
Copy the modified files into a new addon
Add a file named "zzz_write_tiles.rbl" to your addon
Add this template call to "zzz_write_tiles.rbl": {#WRITE_TILESET;./tileset.rbl}
Generate your temporary addon together with Base/Templates

The above steps should create a file named "tileset.rbl", this file has all the needed calls to SET_TILE and SET_COLOR. Now all you need to do is add calls to install the tileset's image file and set the font/init settings you need.

==============================================
Shell Mode:
==============================================

Due to me not wanting to have to distribute another group of 8MB+ binaries I went ahead and built a slightly customized version of the Raptor "shell" program into Rubble.
Although it is called the Raptor shell, the program in question is more of a general Raptor toolkit.

Shell mode provides access to some debugging tools (most of which are for debugging the runtime not scripts, but some are useful) as well as the script compiler and syntax checker.

Shell mode is great for learning Raptor, as you can play around with the various commands and see exactly what they return (in string form) as well as having full access to the commands in the "debug" namespace to help examine things in detail.

The one place the embedded version of the shell differs from the version that comes with Raptor, is that all the commands and variables in the "rubble" namespace are pre-defined, so it is technically possible to simulate a full run of Rubble from the shell. ("technically" because it would be a tremendous amount of typing, so I'm not going to test it)

One thing to keep in mind: Rubble has a copy of the "Shell Predefs" loaded via a init script, so if you want to use the "-init" option you will want to use the "-nopredefs" option as well or Rubble will crash with a script error.

To exit the shell just enter CTRL-Z (on windows, I have no idea how to generate an EOF char on Mac or Linux)

To see a list of all options (for the shell as well as normal) run:
'rubble -h'

To enter the shell run:
'rubble -shell'

To validate a script (syntax check only) run:
'rubble -shell -validate -script="<script path>"'

To validate a script (command and object lit check, may result in false positives) run:
'rubble -shell -validate -all -init -nopredefs -script="<script path>"'

To run a script in batch mode run:
'rubble -shell -script="<script path>"'

To run a script in batch mode and then enter interactive mode run:
'rubble -shell -noexit -script="<script path>"'

To compile a script with the default binary version run:
'rubble -shell -script="<script path>" -compile="<output path>"'

==============================================
Tweak Scripts:
==============================================

Tweak scripts are the most important thing to happen to Rubble since version 1. They allow you to run arbitrary scripts before or after generation. These scripts can change the raws, allowing you to "tweak" the generated output.

Tweak scripts are written in Raptor not Rubble code, so Rubble templates are not available except through rubble:calltemplate or rubble:stageparse.
Each tweak script runs in its own environment just like a Raptor user command. The params array is NOT set!

Most tweak scripts will make use of the commands in the raw namespace to walk the raw files and make changes as needed.

As for writing your own tweak scripts... I suggest you not try unless you have a good understanding of the Raptor language. It would be a very good idea to read the tweak scripts included with Rubble, if you do not understand those scripts then you will have trouble writing your own.

Pitfalls to keep in mind:
	break, if and loop interaction
		break is not at all like the break keyword in most programming languages, for example this example will not work as expected:
			(loop {
				(if (int:eq 1 1) {
					(console:print "1==1")
					(break false)
				})
				(console:print "1!=1 O_O")
				(break true)
			})
		The first break will just make the if command return false. To get the loop to exit you will need to make sure the if command is the last command in the loop. This example is easy to fix, just move the last two commands to the if commands false block, but in many cases it is not so easy.
		The reason that break works the way it does is that break is simply a "soft" return, eg it returns at most one block.
		 
		The breakloop command is much more like the common break keyword but it only works with commands that handle the BreakLoop exit state (loop and foreach as of Raptor v2.0)
		
		The above example rewritten with breakloop:
			(loop {
				(if (int:eq 1 1) {
					(console:print "1==1")
					(breakloop false)
				})
				(console:print "1!=1 O_O")
				
				# equivalent to most languages continue keyword
				# in this case a normal break or even just a bare true would work as well
				# if you do not explicitly return true at the end of a loop you may exit unexpectedly
				(breakloop true)
			})
	
	Declaring variables in loop and foreach
		To put it simply, you can't. Or rather you can, but Rubble will crash with an error on the next iteration. Remember to declare your variables ahead of time and if you REALLY don't want them around after the loop exits just delvar them away or surround the whole mess in a call to evalinnew.

==============================================
Initialization Scripts:
==============================================

Init scripts are very limited, but also very useful. Basically they are Raptor scripts that ALWAYS run, even when their containing addon is not active.
Forced init scripts have the extension ".init.rsf" (or .rbf, .rsf takes precedence).
Use init scripts to do setup that may be shared by multiple addons and HAS to be done. For example an excellent use for a forced init script is adding namespaces and global variables shared by a bunch of addons in an addon pack.

Another fine use of init scripts is "always active" templates, basically you add a template stub in an init script an the override it with a full version in a pre tweak script. This way clients of your addon can just assume that your addon's template are present allowing you to skip checking to see if it is active. 
(please note that you really only want to do this within an addon pack so that you can be sure the other addon is installed)

Init scripts have a very narrow use-case and should be used with care.

Init scripts are still loaded as "user data" if their containing addon contains any parseables!

==============================================
.rbf:
==============================================

"So what's up with this '.rbf' extension that is listed as being parseable?" you ask. 
It stands for "Raptor Binary File" and is used for "compiled" raptor scripts. If for some odd reason you want to make your scripts smaller (why not just make your addon a zip file?) and harder to edit (it is really easy to decompile a .rbf file) you can compile your scripts and use the binary instead of the source.
Why you would want to do this I have no idea, but it didn't take any extra work to allow you to load them, so why not?

In most languages compiling a script would be something you would do to help find errors and/or to reduce file size, in Raptor finding errors is better done with validate and Rubble loads addons from zip files, therefor making binaries (mostly) redundant.

==============================================
The Addon Loader:
==============================================

Rubble has a recursive addon loader that can read addons from zip files or directories.
What this means is that you can group addons in directories to have something like an addon tree.

The following rules determine how addons are loaded:
	Zip files may only be used in the root addon folder.
	Addons in a zip always override addons in a directory.
	Addons are loaded in alphabetical order except as otherwise specified.
	Zip files and directories are identical as far as the loader is concerned except as otherwise specified.
	If an addon contains one or more directories, the directories are loaded as child addons.
	An addon without parseable files (.txt, .rbl, .rsf, .rbf) is not loaded (but any child addons are).
		An init script is not considered a paresable file. (but such a script will still run)

The following rules determine how addon files override each other (if there is a name collision):
	Addons in zip files will always override addons in directories.
	Addons are loaded in alphabetical order, addon "aaa/zzz" will override "aaa/hhh" but not "bbb/aaa"

If you have readmes or the like in an otherwise empty addon it is recommended that you do not give them a file extension, or better yet surround the file contents with <pre></pre> tags and change the extension to .htm, In any case you do not want such an addon appearing in addonlist.ini, so do not use any of the "parseable" extensions (.txt, .rbl, .rsf, .rbf).
WTF was toady thinking when he used the .txt extension for raw files? Why not use .dfr or just .raw? (aside from the fact .raw is used by some audio files)

All addons are loaded into memory, but only the active addons are processed.
An addon is active if:
	It's name is listed on the command line in the -addons option
	If it's entry in addonlist.ini equals "true"

If any addon names are specified via the -addons option then addonlist.ini is never read (but it is updated)

So why do you (the modder) need to know all this? To put it simply you need to know what is permissible for structuring your addon(s) so that you can choose an optimal method that makes it easy on both you and your users. 

Do you want to use multiple small addons or just one large one? Do you want all of your mod's addons in one large directory, or do you want to group related things together? These decisions are important part of deciding how you want to package your mod and how you want the addon list presented to users.

For example Better Dorfs, a mod of mine, groups all of its addons into the "Better Dorfs" addon. This means that users see, for example the Saurians addon, as "Better Dorfs/Saurians". When I add a saurian specific addon I put the new addon in "Better Dorfs/Saurians/<new addon name>". This grouping helps make it obvious what goes with what, making the lives of your users a little more pleasant.

==============================================
Other Random Information:
==============================================

If you want to allow an item, reaction, or building with a minimum of fuss, register it as class "ADDON_HOOK_MOUNTAIN" or "ADDON_HOOK_PLAYABLE". Specific addon hooks also exist for the other entities as well as an ADDON_HOOK_GENERIC that every entity has.

If you are making a template that takes a variable number of params and you want to implement it via a different template you may need the ... param.
Example:
	{!TEMPLATE;E;
		{ECHO;...}
	}
If Rubble finds a template call where the last param is ... it appends the params from the previous template call to the current template's params. This trick is good for aliases and the like.

There is no check for infinite recursion, so make sure you never recurse without breaking out at some point (unless you want to cause an infinite loop and eat all your memory until Rubble crashes). 
The reason there is no recursion check is that there are valid reasons to have deep recursion, and any infinite loops created by recursion like this are errors that should caught in testing. If you are too lazy to do proper testing it is not my job to hold your hand, plus just how many programming languages have you used that had such a check? 

The Raptor command documentation is automatically generated every time I build Rubble, this make it easy for me to keep everything up to date, but the formatting leaves much to be desired.
The problem is that the app that generates the docs is made for go programmers, not Raptor programmers, so a lot of information that has nothing to do with the commands makes it's way to these docs.
Sometime when I'm really bored I need to write a program to automatically reformat these files ;)
