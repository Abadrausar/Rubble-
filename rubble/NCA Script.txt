
Everything You Ever Wanted to Know About NCA 6

==============================================
Overview:
==============================================

NCA is a custom scripting language I wrote that is designed to be easy to embed and extend. I have used NCA for several projects that needed scripting abilities, including Rubble, DCMake, CSVtoINI, and NCASH. NCA is heavily influenced by TCL and like TCL the base syntax is very simple.

For the curious NCA stands for No Clever Acronym (I needed something to use for the package statement and couldn't think of anything clever...)

==============================================
String Syntax
==============================================

NCA supports three kinds of strings: the raw string, the double quote string, and the code string.

The raw string is simply a group of characters with no white space or commas like so: example_raw_string

A double quote string is like the strings supported by most languages, complete with support for the common escape sequences.

A code string is any text (including whitespace and newlines) surrounded by curly brackets eg. {test code string} Code strings may be nested.

==============================================
Commands
==============================================

A command is NCA's version of a function, except in NCA commands also do stuff that is handled by keywords in most languages. To call a command you surround a string containing its name in parentheses, along with any parameter you wish to pass in. 
Example: (The comas are optional)
	(test_command, test_param_1, {test param 2}, "test param 3")

Commands may be named any valid string but by convention they are all valid raw strings

There is no syntax for declaring anew user command, that must be done by a command.

==============================================
Variables
==============================================

Variable support in NCA is like command support, you can read them but not declare them. Declaring a variable is done via a command.

To read a variable you surround its name in square brackets like so: [example_variable]
Variables may contain objects, objects may be Indexable, if so you may pass in a second parameter, the index you want to retrieve: [example_variable, 1] 

==============================================
Namespaces and Environments
==============================================

Variables are stored in environments or namespaces (namespaces may also hold commands and other namespaces). 

Environments are created and destroyed automatically by the State when a user command is called and possibly by some other commands, users have little (direct) control over them. When an environment is destroyed all variables in it are destroyed as well. If the user asks for a variable the current environment is checked first, if the variable is not found then the next one up is checked and so on.

Namespaces must be created by the user via a command, but after a namespace is created it may be written and read from freely. To retrieve a value (or call a command) in a namespace, prefix its name with the namespace name separated by a colon eg. namespace_name:other_name The same procedure is used to add a value, just prefix the name you pass to a deceleration command.

==============================================
Values
==============================================

Script values are stored internaly as several types: string, int, float and object.

The run-time knows how to convert between types automatically, though some types will not yield useful data if converted.

The parser examines incoming data and tries to convert it to an int, if that fails the value is assumed to be a string. Objects and floats are only generated by commands.

Objects are special in that they may be literally anything that a command wants to stuff into a value. Most of the time an object is only understood by commands from the same package as the command that generated it, the exception to this is if the object is Indexable. An Indexable object is special in that the run-time understands how to read data from it natively using the indexing dereference operator. Indexables also have a special interface they present to native commands that allows them to: read data, write data (maybe, some disallow this), get a list of its keys, and get its key count. Indexables are usually things like arrays and maps but may be anything that can implement the correct interface.

Normally the user does not need to know what type the the value is, but there are a few cases where knowing can be very helpful. Strings and ints convert to booleans differently, for example "-1" (a string) is false but -1 (an int) is true. If you need a value to be a specific type there are commands to force convert to (some) types in the base command package.

==============================================
Conclusion
==============================================

The above simple rules are all there is to the NCA base language, everything else is done via commands. NCA is really pretty useless unless at least the base commands are loaded.
