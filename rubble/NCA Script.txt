
Everything You Ever Wanted to Know About NCA 7

==============================================
Overview:
==============================================

NCA is a custom scripting language I wrote that is designed to be easy to embed and extend. I have used NCA for several projects that needed scripting abilities, including Rubble, DCMake, CSVtoINI, and NCASH. NCA is heavily influenced by TCL and like TCL the base syntax is very simple.

For the curious NCA stands for No Clever Acronym (I needed something to use for the package statement and couldn't think of anything clever...)

==============================================
String Syntax
==============================================

NCA supports three kinds of strings: the raw string, the double quote string, and the code string.

The raw string is simply a group of characters with no white space or commas like so: example_raw_string

A double quote string is like the strings supported by most languages, complete with support for the common escape sequences.

A code string is any text (including whitespace and newlines) surrounded by curly brackets eg. {test code string} Code strings may be nested.

==============================================
Commands
==============================================

A command is NCA's version of a function, except in NCA commands also do stuff that is handled by keywords in most languages. To call a command you surround a string containing its name in parentheses, along with any parameter you wish to pass in. 
Example: (The comas are optional)
	(test_command, test_param_1, {test param 2}, "test param 3")

Commands may be named any valid string but by convention they are all valid raw strings

There is no syntax for declaring new user commands, that must be done by a command.

==============================================
Variables
==============================================

Variable support in NCA is like command support, you can read them but not declare them. Declaring a variable is done via a command.

To read a variable you surround its name in square brackets like so: [example_variable]
Variables may contain objects, objects may be Indexable, if so you may pass in a second parameter, the index you want to retrieve: [example_variable, 1]
To read from nested indexables you may either nest the dereferences or just pass them in as a list like so: [test_var 1 2 3] (needless to say the second way is better)
Dereference Syntax: [variable [index...]]

==============================================
Namespaces and Environments
==============================================

Variables are stored in environments or namespaces (namespaces may also hold commands and other namespaces). 

Environments are created and destroyed automatically by the State when a user command is called and possibly by some other commands, users have little (direct) control over them. When an environment is destroyed all variables in it are destroyed as well. If the user asks for a variable the current environment is checked first, if the variable is not found then the next one up is checked and so on.

Namespaces must be created by the user via a command, but after a namespace is created it may be written and read from freely. To retrieve a value (or call a command) in a namespace, prefix its name with the namespace name separated by a colon eg. namespace_name:other_name The same procedure is used to add a value, just prefix the name you pass to a deceleration command.

==============================================
Values
==============================================

Script values are stored internaly as several types: string, int, float, bool and object.

The run-time knows how to convert between types automatically, though some types will not yield useful data if converted.

The parser examines incoming data and tries to convert it to the various types using these rules:
	if lexeme is "true" or "false" type is bool
	if lexeme can be converted into an int without error type is int
	if lexeme can be converted into a float without error type is float
	else type is string

For Objects there is a special syntax. The Object literal syntax only works for types that are registered with the state.
Object Syntax: <type [key=value...]> or <type [value...]>

Objects are special in that they may be literally anything that a command wants to stuff into a value. Most of the time an object is only understood by commands from the same package as the command that generated it, the exception to this is if the object is Indexable. An Indexable object is special in that the run-time understands how to read data from it natively using the indexing dereference operator. Indexables also have a special interface they present to native commands that allows them to: read data, write data (only some), get a list of its keys, and get its key count. Indexables are usually things like arrays and maps but may be anything that can implement the correct interface.

==============================================
Conclusion
==============================================

The above simple rules are all there is to the NCA base language, everything else is done via commands. NCA is really pretty useless unless at least the base commands are loaded.
