
Everything You Ever Wanted to Know About NCA

==============================================
Overview:
==============================================

NCA is a custom scripting language I wrote that is designed to be easy to embed and extend. I have used NCA for several project that needed scripting abilities, including Rubble, DCMake, CSVtoINI, and NCASH. NCA is heavily influenced by TCL and like TCL the base syntax is very simple.

For the curious NCA stands for No Clever Acronym (I needed something to use for the package statement and couldn't think of anything clever...)

==============================================
String Syntax
==============================================

NCA supports three kinds of strings: the raw string, the double quote string, and the code string.

The raw string is simply a group of characters with no white space or commas like so: example_raw_string

A double quote string is like the strings supported by most languages, complete with support for the common escape sequences.

A code string is any text (including white-space and newlines) surrounded by curly brackets eg. {test code string} Code strings may be nested.

==============================================
Commands
==============================================

A command is NCA's version of a function, except in NCA commands also do stuff that is handled by keywords in most languages. To call a command you surround a string containing its name in parentheses, along with any parameter you wish to pass in. 
Example: (The comas are optional)
	(test_command, test_param_1, {test param 2}, "test param 3")

Commands may be named any valid string but by convention the are all valid raw strings

There is no syntax for declaring a command, that must be done by a command.

==============================================
Variables
==============================================

Variable support in NCA is like command support, you can read them but not declare them. Declaring a variable is done via a command.

To read a variable you surround its name in square brackets like so: [example_variable]
Variables may contain maps or arrays, to access map or array indexes you pass in a second parameter, the index you want to retrieve: [example_variable, 1] 
If you want to get a map or array's element count just read it with the normal syntax (eg. no index).

==============================================
Namespaces and Environments
==============================================

Variables are stored in environments or namespaces (namespaces may also hold commands and other namespaces). 

Environments are created and destroyed automaticly by the State when a user command is called and possibly by some other commands, users have little (direct) control over them. When an environment is destroyed all variables in it are destroyed as well. If the user asks for a variable the current environment is checked first, if the variable is not found then the next one up is checked and so on.

Namespaces must be created by the user via a command, but after a namespace is created it may be written and read from freely. To retrieve a value (or call a command) in a namespace, prefix its name with the namespace name separated by a colon eg. namespace_name:other_name The same procedure is used to add a value, just prefix the name you pass to a deceleration command.

==============================================
Conclusion
==============================================

The above simple rules are all there is to the NCA base language, everything else is done via commands. NCA is really pretty useless unless at least the base commands are loaded.
